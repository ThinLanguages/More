<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>More by thin-languages</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>More</h1>
          <h2>Thin Language framework</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/thin-languages/More/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/thin-languages/More/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/thin-languages/More" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a id="more" class="anchor" href="#more" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>More</h1>

<p><a href="https://travis-ci.org/thin-languages/More"><img src="https://travis-ci.org/thin-languages/More.svg?branch=master" alt="Build Status"></a></p>

<p>A Scala based framework for developing modular <a href="thin-languages.uqbar.org">Thin-Languages</a></p>

<h2>
<a id="architecture-basics" class="anchor" href="#architecture-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Architecture Basics</h2>

<p>Instead of defining a language as a single monolithic unit which comprises all functional abstractions along with syntax and
semanthics, <em>More</em> proposes a modular aproach: Turn every feature of your language into a separate module and compose them on
the run!</p>

<h3>
<a id="modules" class="anchor" href="#modules" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Modules</h3>

<p>You can think of each concept available on a language as a separate feature, that can be model as an independent module (For
example, <em>booleans</em>, <em>integers</em>, <em>objects</em> and <em>functions</em> can be isolated modules. More abstract tools like <em>default
parameters</em>, <em>inheritance</em> and <em>destructive asignation</em> can be modules too).</p>

<p>Separating the language notions into modules allow for easier testing and feature flexibility.</p>

<p>Instead of picking a langueage based on it's features, you can pick whatever features you want and combine them for making
the language you want.</p>

<p>To declare a <em>Language Module</em> on More, simply create a <code>trait</code> and define inside it any structure you need to support the
new concepts. All concepts should extend the <code>LanguageConcept</code> trait or another, higher order, concept.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">trait</span> <span class="pl-en">YourModule</span> {
    <span class="pl-k">trait</span> <span class="pl-en">YourNewConcept</span> <span class="pl-k">extends</span> <span class="pl-e">LanguageConcept</span>
}</pre></div>

<p>You can then declare a language by just combining any modules you want!</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">object</span> <span class="pl-en">YourLanguage</span> <span class="pl-k">extends</span> <span class="pl-e">Language</span>
    <span class="pl-k">with</span> <span class="pl-e">OneModule</span>
    <span class="pl-k">with</span> <span class="pl-e">OtherModule</span></pre></div>

<p>Of course, some modules would need to use or redefine concepts presented by other modules. Scala language already provides an
easy way of handling this: just linearize your traits as needed.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">trait</span> <span class="pl-en">YourModule</span> <span class="pl-k">extends</span> <span class="pl-e">SomeOtherModule</span> {
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">YourNewConcept</span>(<span class="pl-v">aField</span>: <span class="pl-en">SomeOtherModuleTypeConcept</span>) <span class="pl-k">extends</span> <span class="pl-e">SomeOtherModuleConcept</span>
}</pre></div>

<p>Remember that, in order to remain true to the Thin ideas, the language concepts themselves should only be the <em>abstract
representation of your language ideas</em>. That means that they should refrain from containing syntactic related elements. This
way they are easier to combine, and the syntax can be define for each user, or even create new <em>projective view</em> that
represent it in a whole different way, maybe without any code at all.</p>

<h3>
<a id="views" class="anchor" href="#views" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Views</h3>

<p>So where IS the syntax? Well, setting aside that Thin Languages don't really NEED to have ONE syntax, most language will
need a way to be written into (and read from) text. Of course, some languages may also want to work their concepts using
different, crazier interfaces, that could be implemented in all kinds of frontend technologies.</p>

<p>For this <em>More</em> defines the <code>LanguageView</code> trait.</p>

<p>Think of a View as a two-way route between your <em>Language Concepts</em> and some representation (text based or not) that a
frontend tool can use to render them and let a user interact with a program definition.</p>

<p>With this in mind, the <code>LanguageView</code> trait should be quite simple to understand:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">trait</span> <span class="pl-en">LanguageView</span>[<span class="pl-en">ViewModel</span>, <span class="pl-en">ViewOptions</span>, <span class="pl-en">LanguageRequirement</span>] {
    <span class="pl-k">def</span> <span class="pl-en">encode</span>(<span class="pl-v">target</span>: <span class="pl-en">LanguageConcept</span>)(<span class="pl-k">implicit</span> <span class="pl-v">language</span>: <span class="pl-en">LanguageRequirement</span>, <span class="pl-v">options</span>: <span class="pl-en">ViewOptions</span>)<span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">ViewModel</span>]
    <span class="pl-k">def</span> <span class="pl-en">decode</span>(<span class="pl-v">target</span>: <span class="pl-en">ViewModel</span>)(<span class="pl-k">implicit</span> <span class="pl-v">language</span>: <span class="pl-en">LanguageRequirement</span>,  <span class="pl-v">options</span>: <span class="pl-en">ViewOptions</span>)<span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">LanguageConcept</span>]
}</pre></div>

<p>Where:</p>

<ul>
<li>
<code>ViewModel</code> is the type the view knows how to render. E.g. the ViewModel of a very simple view that renders code could be
<code>String</code>, since it would take the object graph that represents your program and turn it into a code string and v.v.</li>
<li>
<code>ViewOptions</code> is the type of the structure used by the view to contain any preference the user may have for the
transformation.
E.g. for a source view you may like to tabulate with spaces of tabs, so that should be a field in your view
ViewOptions object.</li>
<li>
<code>LanguageRequirement</code> is a trait that any language that wants to be render by the View should implement. This provides the
view with a way to request any logic that may be needed to turn from your language's model to the view's model.
E.g. a source view may need a grammar definition to convert your language concepts into a source string. Instead of
implementing that itself (which would be very hard to do without deeply coupling it with some modules) it just declares it
as a needed piece of info that must be provided. This helps keeping the views simple and short.</li>
</ul>

<p>Once this is clear, you can see that the <code>encode</code> and <code>decode</code> methods are just transformers that let you go from the
Models defined in your modules to a ViewModel instance and back again.</p>

<p>If any of this results a bit overwhelming, don't worry! Unless you want your model to be represented in a completely new way
you probably will have no need to define your own views. The good thing about keeping the views completely decoupled from
any LanguageConcept is that most common possible views should already be implemented and can be used with any language that
meets the requirements. One example of that is More's <code>SourceView</code> which should be able to turn any language into source
code, as long as they implement the <code>Sourceable</code> trait.</p>

<p>Remember, Views should only be defined if, for some reason, a frontend tool requires a different representation of your
language's programs.</p>

<h3>
<a id="the-presenter-pattern" class="anchor" href="#the-presenter-pattern" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Presenter Pattern</h3>

<p>Let's say you have created some language modules and would like use them along with a view:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-c">// Your Modules</span>
<span class="pl-k">trait</span> <span class="pl-en">FooModule</span> {
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">n</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">LanguageConcept</span>
}

<span class="pl-k">trait</span> <span class="pl-en">BarModule</span> {
  <span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Bar</span> <span class="pl-k">extends</span> <span class="pl-e">LanguageConcept</span>
}

<span class="pl-c">//Your View</span>
<span class="pl-k">trait</span> <span class="pl-en">FancyView</span>[
  <span class="pl-en">FancyModel</span>, <span class="pl-c">// What the FancyView can turn your model from/into.</span>
  <span class="pl-en">FancyOptions</span>, <span class="pl-c">// Some preferences the view may have.</span>
  <span class="pl-en">Fanciable</span> <span class="pl-c">// The requirements the view impose to the language. This is stuff needed by the view to encode/decode.</span>
] { ... }

<span class="pl-k">trait</span> <span class="pl-en">Fanciable</span> {
  <span class="pl-k">def</span> <span class="pl-en">getTheFancy</span>(<span class="pl-v">target</span>: <span class="pl-en">LanguageConcept</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Fancy</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>
}

<span class="pl-c">// Your Language</span>
<span class="pl-k">object</span> <span class="pl-en">YourLanguage</span> <span class="pl-k">extends</span> <span class="pl-e">Language</span>
  <span class="pl-k">with</span> <span class="pl-e">FooModule</span>
  <span class="pl-k">with</span> <span class="pl-e">BarModule</span></pre></div>

<p>From the code you can tell the the <code>FancyView</code> need the language to extend the <code>Fanciable</code> trait in order to work. As in
any other view, the LanguageRequirement traits are probably going to be the place where the hard stuff takes place.
Of course, you could design your modules to implement those requirements themselves, but that would make very
hard to implement a new module (since it would have to provide all logic needed by any views it would be used on). <em>More</em>
architecture is design to allow modules and views to be developed independently, completely decoupled from each other. We
think it is a good idea to allow modules to be removed or added any time from a language, without having to worry about
breaking the views.</p>

<p>Alternatively, you can just add a huge implementation of the language requirement in the language itself:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">object</span> <span class="pl-en">YourLanguage</span> <span class="pl-k">extends</span> <span class="pl-e">Language</span> <span class="pl-k">with</span> <span class="pl-e">Fanciable</span>
  <span class="pl-k">with</span> <span class="pl-e">FooModule</span>
  <span class="pl-k">with</span> <span class="pl-e">BarModule</span> {

  <span class="pl-k">def</span> <span class="pl-en">getTheFancy</span>(<span class="pl-v">target</span>: <span class="pl-en">LanguageConcept</span>) <span class="pl-k">=</span> target <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(n) <span class="pl-k">=&gt;</span> <span class="pl-c">// Some Foo fancy</span>
    <span class="pl-k">case</span> <span class="pl-en">Bar</span> <span class="pl-k">=&gt;</span> <span class="pl-c">// Some Bar fancy</span>
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-v">super</span>.getTheFancy(target)
  }
}</pre></div>

<p>Althought this would kind of solve the problem it would be very repetitive, since every language that wants to render these
modules with this view would have to repeat this code (and probably extend it to cover all the modules it wants to use),
plus, the code would probably be very long and complex.</p>

<p>The proposal of <em>More</em>'s architecture is to apply a <em>Presenter Pattern</em>, creating a small trait that provides whatever a
single view needs for each module. That way each module becomes available of being render by a view (independently of
others) without becoming coupled with the view itself.</p>

<p>Here is how the final version would be:</p>

<div class="highlight highlight-source-scala"><pre>
<span class="pl-k">trait</span> <span class="pl-en">FanciableFoo</span> <span class="pl-k">extends</span> <span class="pl-e">Fanciable</span> {<span class="pl-v">on</span>: <span class="pl-en">Foo</span> <span class="pl-k">=&gt;</span>
  <span class="pl-k">def</span> <span class="pl-en">getTheFancy</span>(<span class="pl-v">target</span>: <span class="pl-en">LanguageConcept</span>) <span class="pl-k">=</span> target <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(n) <span class="pl-k">=&gt;</span> <span class="pl-c">// Some Foo fancy</span>
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-v">super</span>.getTheFancy(target)
  }
}

<span class="pl-k">trait</span> <span class="pl-en">FanciableBar</span> <span class="pl-k">extends</span> <span class="pl-e">Fanciable</span> { <span class="pl-v">on</span>: <span class="pl-en">Bar</span> <span class="pl-k">=&gt;</span>
  <span class="pl-k">def</span> <span class="pl-en">getTheFancy</span>(<span class="pl-v">target</span>: <span class="pl-en">LanguageConcept</span>) <span class="pl-k">=</span> target <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-en">Bar</span> <span class="pl-k">=&gt;</span> <span class="pl-c">// Some Bar fancy</span>
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-v">super</span>.getTheFancy(target)
  }
}

<span class="pl-k">object</span> <span class="pl-en">YourLanguage</span> <span class="pl-k">extends</span> <span class="pl-e">Language</span>
  <span class="pl-k">with</span> <span class="pl-e">FooModule</span> <span class="pl-k">with</span> <span class="pl-e">FanciableFoo</span>
  <span class="pl-k">with</span> <span class="pl-e">BarModule</span> <span class="pl-k">with</span> <span class="pl-e">FanciableBar</span></pre></div>

<p>Notice how, if properly implemented, there would be no need for the language to declare any code, but it could be used,
as any other type, to solve conflicts between modules or presenters. Also notice that each presenter should only need to be
coded once, and be rehused by any language that wants to render with the FancyView, regardless of what other modules it
uses.</p>

<p>Presenters for popular views could be included in the modules packages themselves while presenters for new views could be
declared anywhere, without affecting languages that won't use them.</p>

<h2>
<a id="related-projects" class="anchor" href="#related-projects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Related Projects</h2>

<p>For a growing sanitized set of modules that work well with each other you can check the <a href="https://github.com/thin-languages/Less">Less Thin-Language</a></p>

<p>We are also working on <a href="https://github.com/thin-languages/Slimdown">Slimdown</a> a Thin-IDE, to provide desktop support to any <em>More</em> based language.</p>

<h2>
<a id="contributions" class="anchor" href="#contributions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributions</h2>

<p>Sure! Pull requests are always welcome, just try to keep it small and clean. Also feel free to post any question or bug
report in the issue tracker.</p>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h2>

<p>This code is open source software licensed under the <a href="https://www.gnu.org/licenses/lgpl.html">LGPL v3 License</a> by <a href="http://www.uqbar-project.org/">The Uqbar Foundation</a>. Feel free to use it accordingly.</p>
        </section>

        <footer>
          More is maintained by <a href="https://github.com/thin-languages">thin-languages</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
