{
  "name": "More",
  "tagline": "Thin Language framework",
  "body": "# More\r\n\r\n[![Build Status](https://travis-ci.org/thin-languages/More.svg?branch=master)](https://travis-ci.org/thin-languages/More)\r\n\r\nA Scala based framework for developing modular [Thin-Languages](thin-languages.uqbar.org)\r\n\r\n##Architecture Basics\r\nInstead of defining a language as a single monolithic unit which comprises all functional abstractions along with syntax and\r\nsemanthics, *More* proposes a modular aproach: Turn every feature of your language into a separate module and compose them on\r\nthe run!\r\n\r\n###Modules\r\nYou can think of each concept available on a language as a separate feature, that can be model as an independent module (For\r\nexample, *booleans*, *integers*, *objects* and *functions* can be isolated modules. More abstract tools like *default\r\nparameters*, *inheritance* and *destructive asignation* can be modules too).\r\n\r\nSeparating the language notions into modules allow for easier testing and feature flexibility.\r\n\r\nInstead of picking a langueage based on it's features, you can pick whatever features you want and combine them for making\r\nthe language you want.\r\n\r\nTo declare a *Language Module* on More, simply create a `trait` and define inside it any structure you need to support the\r\nnew concepts. All concepts should extend the `LanguageConcept` trait or another, higher order, concept.\r\n\r\n```scala\r\ntrait YourModule {\r\n\ttrait YourNewConcept extends LanguageConcept\r\n}\r\n```\r\n\r\nYou can then declare a language by just combining any modules you want!\r\n\r\n```scala\r\nobject YourLanguage extends Language\r\n\twith OneModule\r\n\twith OtherModule\r\n```\r\n\r\nOf course, some modules would need to use or redefine concepts presented by other modules. Scala language already provides an\r\neasy way of handling this: just linearize your traits as needed.\r\n\r\n```scala\r\ntrait YourModule extends SomeOtherModule {\r\n\tcase class YourNewConcept(aField: SomeOtherModuleTypeConcept) extends SomeOtherModuleConcept\r\n}\r\n```\r\n\r\nRemember that, in order to remain true to the Thin ideas, the language concepts themselves should only be the *abstract\r\nrepresentation of your language ideas*. That means that they should refrain from containing syntactic related elements. This\r\nway they are easier to combine, and the syntax can be define for each user, or even create new *projective view* that\r\nrepresent it in a whole different way, maybe without any code at all.\r\n\r\n###Views\r\nSo where IS the syntax? Well, setting aside that Thin Languages don't really NEED to have ONE syntax, most language will\r\nneed a way to be written into (and read from) text. Of course, some languages may also want to work their concepts using\r\ndifferent, crazier interfaces, that could be implemented in all kinds of frontend technologies.\r\n\r\nFor this *More* defines the `LanguageView` trait.\r\n\r\nThink of a View as a two-way route between your *Language Concepts* and some representation (text based or not) that a\r\nfrontend tool can use to render them and let a user interact with a program definition.\r\n\r\nWith this in mind, the `LanguageView` trait should be quite simple to understand:\r\n\r\n```scala\r\ntrait LanguageView[ViewModel, ViewOptions, LanguageRequirement] {\r\n\tdef encode(target: LanguageConcept)(implicit language: LanguageRequirement, options: ViewOptions): Try[ViewModel]\r\n\tdef decode(target: ViewModel)(implicit language: LanguageRequirement,  options: ViewOptions): Try[LanguageConcept]\r\n}\r\n```\r\n\r\nWhere:\r\n- `ViewModel` is the type the view knows how to render. E.g. the ViewModel of a very simple view that renders code could be\r\n`String`, since it would take the object graph that represents your program and turn it into a code string and v.v.\r\n- `ViewOptions` is the type of the structure used by the view to contain any preference the user may have for the\r\ntransformation.\r\nE.g. for a source view you may like to tabulate with spaces of tabs, so that should be a field in your view\r\nViewOptions object.\r\n- `LanguageRequirement` is a trait that any language that wants to be render by the View should implement. This provides the\r\nview with a way to request any logic that may be needed to turn from your language's model to the view's model.\r\nE.g. a source view may need a grammar definition to convert your language concepts into a source string. Instead of\r\nimplementing that itself (which would be very hard to do without deeply coupling it with some modules) it just declares it\r\nas a needed piece of info that must be provided. This helps keeping the views simple and short.\r\n\r\nOnce this is clear, you can see that the `encode` and `decode` methods are just transformers that let you go from the\r\nModels defined in your modules to a ViewModel instance and back again.\r\n\r\nIf any of this results a bit overwhelming, don't worry! Unless you want your model to be represented in a completely new way\r\nyou probably will have no need to define your own views. The good thing about keeping the views completely decoupled from\r\nany LanguageConcept is that most common possible views should already be implemented and can be used with any language that\r\nmeets the requirements. One example of that is More's `SourceView` which should be able to turn any language into source\r\ncode, as long as they implement the `Sourceable` trait.\r\n\r\nRemember, Views should only be defined if, for some reason, a frontend tool requires a different representation of your\r\nlanguage's programs.\r\n\r\n###The Presenter Pattern\r\nLet's say you have created some language modules and would like use them along with a view:\r\n\r\n```scala\r\n// Your Modules\r\ntrait FooModule {\r\n  case class Foo(n: Int) extends LanguageConcept\r\n}\r\n\r\ntrait BarModule {\r\n  case object Bar extends LanguageConcept\r\n}\r\n\r\n//Your View\r\ntrait FancyView[\r\n  FancyModel, // What the FancyView can turn your model from/into.\r\n  FancyOptions, // Some preferences the view may have.\r\n  Fanciable // The requirements the view impose to the language. This is stuff needed by the view to encode/decode.\r\n] { ... }\r\n\r\ntrait Fanciable {\r\n  def getTheFancy(target: LanguageConcept): Option[Fancy] = None\r\n}\r\n\r\n// Your Language\r\nobject YourLanguage extends Language\r\n  with FooModule\r\n  with BarModule\r\n```\r\n\r\nFrom the code you can tell the the `FancyView` need the language to extend the `Fanciable` trait in order to work. As in\r\nany other view, the LanguageRequirement traits are probably going to be the place where the hard stuff takes place.\r\nOf course, you could design your modules to implement those requirements themselves, but that would make very\r\nhard to implement a new module (since it would have to provide all logic needed by any views it would be used on). *More*\r\narchitecture is design to allow modules and views to be developed independently, completely decoupled from each other. We\r\nthink it is a good idea to allow modules to be removed or added any time from a language, without having to worry about\r\nbreaking the views.\r\n\r\nAlternatively, you can just add a huge implementation of the language requirement in the language itself:\r\n\r\n```scala\r\nobject YourLanguage extends Language with Fanciable\r\n  with FooModule\r\n  with BarModule {\r\n  \r\n  def getTheFancy(target: LanguageConcept) = target match {\r\n    case Foo(n) => // Some Foo fancy\r\n    case Bar => // Some Bar fancy\r\n    case _ => super.getTheFancy(target)\r\n  }\r\n}\r\n```\r\n\r\nAlthought this would kind of solve the problem it would be very repetitive, since every language that wants to render these\r\nmodules with this view would have to repeat this code (and probably extend it to cover all the modules it wants to use),\r\nplus, the code would probably be very long and complex.\r\n\r\nThe proposal of *More*'s architecture is to apply a *Presenter Pattern*, creating a small trait that provides whatever a\r\nsingle view needs for each module. That way each module becomes available of being render by a view (independently of\r\nothers) without becoming coupled with the view itself.\r\n\r\nHere is how the final version would be:\r\n\r\n```scala\r\n\r\ntrait FanciableFoo extends Fanciable {on: Foo =>\r\n  def getTheFancy(target: LanguageConcept) = target match {\r\n    case Foo(n) => // Some Foo fancy\r\n    case _ => super.getTheFancy(target)\r\n  }\r\n}\r\n\r\ntrait FanciableBar extends Fanciable { on: Bar =>\r\n  def getTheFancy(target: LanguageConcept) = target match {\r\n    case Bar => // Some Bar fancy\r\n    case _ => super.getTheFancy(target)\r\n  }\r\n}\r\n\r\nobject YourLanguage extends Language\r\n  with FooModule with FanciableFoo\r\n  with BarModule with FanciableBar\r\n```\r\n\r\nNotice how, if properly implemented, there would be no need for the language to declare any code, but it could be used,\r\nas any other type, to solve conflicts between modules or presenters. Also notice that each presenter should only need to be\r\ncoded once, and be rehused by any language that wants to render with the FancyView, regardless of what other modules it\r\nuses.\r\n\r\nPresenters for popular views could be included in the modules packages themselves while presenters for new views could be\r\ndeclared anywhere, without affecting languages that won't use them.\r\n\r\n##Related Projects\r\n\r\nFor a growing sanitized set of modules that work well with each other you can check the [Less Thin-Language](https://github.com/thin-languages/Less)\r\n\r\nWe are also working on [Slimdown](https://github.com/thin-languages/Slimdown) a Thin-IDE, to provide desktop support to any *More* based language.\r\n\r\n##Contributions\r\n\r\nSure! Pull requests are always welcome, just try to keep it small and clean. Also feel free to post any question or bug\r\nreport in the issue tracker.\r\n\r\n##License\r\n\r\nThis code is open source software licensed under the [LGPL v3 License](https://www.gnu.org/licenses/lgpl.html) by [The Uqbar Foundation](http://www.uqbar-project.org/). Feel free to use it accordingly.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}